<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: run.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: run.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _        = require("underscore")
  , bunyan   = require("bunyan")
  , ndata    = require('ndata')
  , deflt    = require("./default")
  , worker   = require("./worker")
  , utils    = require("./utils")
  , log      = bunyan.createLogger({name: deflt.appname})
  , cstr     = deflt.ctrlStr
  , ok       = {ok:true}
  , mem      = ndata.createClient({port: deflt.mem.port})
  , timer    = {};

/**
 * Subscriptions
 * @method ini
 * @param {Function} cb
 */
var ini = function(cb){
  mem.subscribe(cstr.run, function(err){
    if(!err){
      log.info(ok
              , "run.js subscribed to run channel");
      mem.subscribe(cstr.exec, function(err){
        if(!err){
          log.info(ok
                  , "run.js subscribed to executed channel");

          mem.subscribe("stop", function(err){
            if(!err){
              log.info(ok
                      , "run.js subscribed to stop channel");
              if( _.isFunction(cb)){
                cb(ok);
              }
            }else{
              log.info({error:err}
                      , "error on stop subscription in run.js");
            }
          }); // stop
        }else{
          log.info({error:err}
                  , "error on executed subscription in run.js");
        }
      }); // exec
    }else{
      log.info({error:err}
              , "error on run subscription in jun.js");
    }
  }); // run
}
exports.ini = ini;

mem.on('message', function(ch, path){
  var strpath = path.join(" ")
    , endseq  = false
    , mpid    = path[0]
    , no      = path[1]

  if(ch == "stop"){
    if(timer[strpath]){
      log.info(ok
              , "receice stop event, clear intervall timer id");
      clearInterval(timer[strpath])
      timer[strpath] = 0;
    }
  }


  if(ch == "executed"){
    if(timer[strpath]){
      log.info(ok
              , "receice executed event, clear intervall timer id");
      clearInterval(timer[strpath])
      timer[strpath] = 0;
    }
  }

  if(ch == "run"){
    log.info(ok
            , "receice run event, start intervall timer");
    if(!timer[strpath]){
    timer[strpath] = setInterval(function(){
                       mem.get([mpid, no, "state"], function(err, state){
                         if(!err){
                           for(var i in state){

                             var some_values_ready = _.some(_.values(state[i]),function(k){
                                                       return k == cstr.ready;
                                                     });

                             if(some_values_ready){
                               for(var j in state[i]){
                                 if(state[i][j] == cstr.ready){
                                   var path_s = [mpid, no, "state", i, j];

                                   mem.set(path_s, cstr.work, function(s,p){
                                                                return function(err){
                                                                  mem.publish("state", [mpid, no, "state",s,p], function(err){
                                                                    if(!err){
                                                                      endseq = true;
                                                                      var path_r = [mpid, no, "recipe",s,p];
                                                                      mem.get(path_r, function(err, task){
                                                                        if(!err){
                                                                          //------------------
                                                                          run(path, s, p, task);
                                                                          //------------------
                                                                        }else{
                                                                       log.err({error: err}
                                                                               , "can not read recipe on position " + path_r.join(" "));
                                                                     }
                                                                   });
                                                                 }else{
                                                                   log.err({error:err}
                                                                          , "can not set state at " + path_s.join(" "));
                                                                 }
                                                               }); // publisch state
                                                             }}(i,j)); // set work closure
                              }// if ready
                            }  // j
                          } // contains ready

                          // solange bei i bleiben (break)
                          // bis nicht alle ausgef체hrt sind
                          var all_values_executed = _.every(_.values(state[i]),function(k){
                                                      return k == cstr.exec;
                                                    });
                          if(! all_values_executed){
                            break;
                          }
                        } // i
                      }else{
                        log.error({error: err}
                                 , "can not read state");

                      }
                    }); // state
                     }, deflt.container.heartbeat);
    }else{
      log.warn({warn: "running"}
              , "container is already running");

    }
  }
});
/**
 *  * --*-- run --*--
 * Die Funktion ```run()```  erledigt folgende Aufgaben:
 * w채hlt die richtige  ```worker```-Funktion aus und stellt den
 * callback zur Verf체gung
 * RunIf und StopIf werden entschieden
 * es werden die Laufzeitersetzungen vorgenommen
 * (Bsp.: der String f체r den MKS-Flow Kontroller)
 * @method run
 * @param {Array} path
 * @param {Number} s
 * @param {Number} p
 * @param {Object} task
 */
var run = function(path, s, p, task){
  var mpid    = path[0]
    , no      = path[1]
    , path_e  = [mpid, "exchange"]
    , path_s  = [mpid, no, "state", s, p];

  if(_.isObject(task) &amp;&amp; task.Action &amp;&amp; _.isFunction(worker[task.Action])){
    var ok      = true
      , ro      = {ok:ok}
      , exec    = task.Action
      , cmdstr  = cstr.exec
      , tsknm   = task.TaskName

    task_exchange(path_e, task, ok, cmdstr, function(ok, cmdstr){
      task_stop_if(path_e, task, ok, cmdstr, function(ok, cmdstr){
        task_run_if(path_e, task, ok, cmdstr, function(ok, cmdstr){

          mem.publish("worker", exec, function(err){
            if(!err){
              log.info(ro
                      ,"worker event published");
              if(ok){
                var delay = parseInt(p, 10) * deflt.system.par_delay_mult;
                setTimeout(function(){
                  log.info(ro
                          , "start " + tsknm + " with a delay of " + delay + "ms")
                  // -------------------------------------------------------
                  task.Path = path;
                  worker[exec](task, function(res){

                    if(res.again){
                      mem.set( path_s, cstr.ready, function(){
                        mem.publish("state", path_s, function(err){
                          if(!err){
                            log.info(ro
                                    ,"state event published");
                          }else{
                            log.error({error: err}
                                     , "unable to publish state event");
                          }
                        }); // publish
                      }); // state set
                    } // return again

                    if(res.ok){
                      mem.set(path_s, cmdstr, function(){
                        mem.publish("state",  path_s, function(err){
                          if(!err){
                            log.info(ro
                                    ,"state event published");
                          }else{
                            log.error({error: err}
                                     , "unable to publish state event");
                          }
                        }); // publish
                      })
                    } // return ok

                    if(res.error){
                      mem.set(path_s, cstr.error, function(){
                        mem.publish("state",  path_s, function(err){
                          if(!err){
                            log.info(ro
                                    ,"state event published");
                          }else{
                            log.error({error: err}
                                     , "unable to publish state event");
                          }
                        }); // publish
                        log.error(res
                                 , "task " + tsknm + " task execution failed")
                      });
                    } // return with error
                  });
                  // -------------------------------------------------------
                }, delay);
              }else{

                mem.set(path_s, cmdstr, function(err){
                  if(!err){
                    log.info(ro
                            , "set " + path_s.join(".") + " to: " + cmdstr);
                    mem.publish("state", path_s, function(err){
                      if(!err){
                        log.info(ro
                                ,"state event published");
                      }else{
                        log.error({error: err}
                               , "unable to publish state event");
                      }
                    }); // publish
                  }else{
                    log.error({error: err}
                             , "on set state");
                  }
                });
              }// worker[exec]
            }else{
              log.error({error:err}
                       , "error on publishing exec: " + exec)
            }
          }); // publish
        }); // runif
      }); // stopif
    }); // exchange
  }else{// task is obj
    mem.set(path_s, cstr.error, function(){
      log.error(task
               , "task don't work (most likely unknown Action)")
    });
  }
}



/**
 * Description
 * @method task_exchange
 * @param {Array} path
 * @param {Object} task
 * @param {Boolean} ok
 * @param {String} cmdstr
 * @param {Function} cb
 */
var task_exchange = function(path, task, ok, cmdstr, cb){

  // --- Runtime data exchange
  if(task.FromExchange){
    if(_.isArray(task.FromExchange)){
      var N = task.FromExchange.length;
      for( var l = 0; l &lt; N; l++){
        var path_l = task.FromExchange[l].split(".");
        mem.get(path.concat(path_l), function(last){
                                       return function(err, value){
                                         if(!err){
                                           var    token = task.FromExchange[l];
                                           if(token &amp;&amp; value){
                                             task =  utils.replace_in_with(task, token , value );
                                           }else{
                                             ok = false;
                                           }
                                         }else{
                                           log.info({error: err}
                                                   , "can not read exchange at " + task.FromExchange[l]);
                                         }
                                         if(last){
                                           cb(ok, cmdstr);
                                         }
                                       }
                                     }(l == N - 1)); // get exchange
      } // for
    }else{
      var path_l = task.FromExchange.split(".");
      mem.get(path.concat(path_l), function(err, value){
        if(!err){
          var token = task.FromExchange;
          if(token &amp;&amp; value){
            task =  utils.replace_in_with(task, token , value);
          }else{
            ok = false;
          }
        }else{
          log.info({error: err}
                  , "can not read exchange at "+ task.FromExchange);
        }
        cb(ok, cmdstr);
      })// get exchange
    } // else
  }else{ // Exchange
    cb(ok, cmdstr);
  }
}

/**
 * Description
 * @method task_stop_if
 * @param {Array} path
 * @param {Object} task
 * @param {Boolean} ok
 * @param {String} cmdstr
 * @param {Function} cb
 */
var task_stop_if = function(path, task, ok, cmdstr, cb){
  var tsknm = task.TaskName

  // --- StopIf
  if(task.StopIf){
    var path_s = task.StopIf.split(".");
    mem.get(path.concat(path_s), function(err, value){
      if(!err){
        if(value ==  true || value == "true"){
          ok     = false;
          cmdstr = cstr.exec;
        }else{
          ok     = true;
          cmdstr = cstr.ready;
        }
      }else{
        log.info({error: err}
                , "can not read exchange at " + task.StopIf);
      }
      cb(ok, cmdstr);
    }); // get stop if state
  }else{ // StopIf
    cb(ok, cmdstr);
  }
}

/**
 * Description
 * @method task_run_if
 * @param {Array} path
 * @param {Object} task
 * @param {Boolean} ok
 * @param {String} cmdstr
 * @param {Function} cb
*/
var task_run_if = function(path, task, ok, cmdstr, cb){
  var tsknm = task.TaskName
  // --- RunIf
  if(task.RunIf){
    var path_r = task.RunIf.split(".");
    mem.get(path.concat(path_r), function(err, value){
      if(!err){
        if(value ==  true || value == "true"){
          ok     = true;
          cmdstr = cstr.exec;
        }else{
          ok     = false;
          cmdstr = cstr.ready;
        }
      }else{
        log.error({error: err}
                , "can not read exchange at " + task.RunIf);
      }
      cb(ok, cmdstr);
    }); // get run if state
  }else{// RunIf
    cb(ok, cmdstr);
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#_">_</a></li><li><a href="global.html#all">all</a></li><li><a href="global.html#all_same">all_same</a></li><li><a href="global.html#as_arr">as_arr</a></li><li><a href="global.html#build_base">build_base</a></li><li><a href="global.html#build_container">build_container</a></li><li><a href="global.html#cb">cb</a></li><li><a href="global.html#checkDB">checkDB</a></li><li><a href="global.html#checkdb">checkdb</a></li><li><a href="global.html#checkRelay">checkRelay</a></li><li><a href="global.html#cmd_to_array">cmd_to_array</a></li><li><a href="global.html#container">container</a></li><li><a href="global.html#cp">cp</a></li><li><a href="global.html#ctrlContainer">ctrlContainer</a></li><li><a href="global.html#data_to_doc">data_to_doc</a></li><li><a href="global.html#distribute_def">distribute_def</a></li><li><a href="global.html#docinfo">docinfo</a></li><li><a href="global.html#eq">eq</a></li><li><a href="global.html#exec">exec</a></li><li><a href="global.html#expand_cust">expand_cust</a></li><li><a href="global.html#expand_task">expand_task</a></li><li><a href="global.html#exports">exports</a></li><li><a href="global.html#fetchtask">fetchtask</a></li><li><a href="global.html#getDate">getDate</a></li><li><a href="global.html#getList">getList</a></li><li><a href="global.html#getTime">getTime</a></li><li><a href="global.html#gt">gt</a></li><li><a href="global.html#ini">ini</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#lt">lt</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nodeRelay">nodeRelay</a></li><li><a href="global.html#pad0">pad0</a></li><li><a href="global.html#query_cd">query_cd</a></li><li><a href="global.html#rddoc">rddoc</a></li><li><a href="global.html#readExchange">readExchange</a></li><li><a href="global.html#relay">relay</a></li><li><a href="global.html#repl">repl</a></li><li><a href="global.html#replace_in_with">replace_in_with</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#shout">shout</a></li><li><a href="global.html#task">task</a></li><li><a href="global.html#task_exchange">task_exchange</a></li><li><a href="global.html#task_run_if">task_run_if</a></li><li><a href="global.html#task_stop_if">task_stop_if</a></li><li><a href="global.html#updateCd">updateCd</a></li><li><a href="global.html#vl_date">vl_date</a></li><li><a href="global.html#vl_time">vl_time</a></li><li><a href="global.html#wait">wait</a></li><li><a href="global.html#write_to_exchange">write_to_exchange</a></li><li><a href="global.html#writeExchange">writeExchange</a></li><li><a href="global.html#wrtdoc">wrtdoc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta1</a> on Mon Feb 16 2015 09:34:13 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
