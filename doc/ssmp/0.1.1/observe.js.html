<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: observe.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: observe.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Die Funktion ```observe()``` beobachtet periodisch
 * die ```/ctrl``` Schnittstelle aller _Container_ des
 * Messprogramms  und deren ```/state``` (Zustand der einzelnen Tasks).
 *
 * Für den Fall, dass alle
 * ```state```s eines _Containers_  den Wert ```executed```
 * besitzen, wird deren Wert auf  ```ready``` zurückgesetzt.
 *
 * Der _Container gilt dann als abgearbeitet.
 * der ```/ctrl``` String des _Containers_ wird dann
 * ebenfalls auf den Wert ```ready``` gesetzt.
 *
 * Die Funktion wird durch den
 * Messprogramminitialisierungsprozess gestartet.
 *
 * Die ```observe()``` Funktion reagiert auf:
 *
 * - load
 * - run
 * - stop
 * - pause
 *
 * Darüber hinaus werden die beiden ```/exchange```
 * Objekte:
 * ```
 * "start_time": {
 *     "Value": {
 *         "value": 1408712602709
 *     },
 *     "Unit": {
 *         "value": "ms"
 *     }
 * }
 * ```
 * und
 * ```
 * "run_time": {
 *     "Unit": {
 *         "value": "ms"
 *     },
 *     "Value": {
 *         "value": 928429
 *     }
 *
 * }
 * ```
 * erstellt; letzterer periodisch aufgefrischt.
 *
 */
var _        = require("underscore")
  , bunyan   = require("bunyan")
  , clone    = require("clone")
  , ndata    = require('ndata')
  , utils    = require("./utils")
  , deflt    = require("./default")
  , log      = bunyan.createLogger({name: deflt.appname})
  , sh       = deflt.system.heartbeat
  , ch       = deflt.container.heartbeat
  , cstr     = deflt.ctrlStr
  , timerId  = {}
  , ok       = {ok:true}
  , mem      = ndata.createClient({port: deflt.mem.port});

/**
 * Description
 * @method ini
 * @param {Function} cb
 */
var ini = function(cb){
  mem.subscribe("buildup", function(err){
    if(!err){
      log.info(ok
              , "observe.js subscribed to buildup channel");

      mem.subscribe("builddown", function(err){
        if(!err){
          log.info(ok
                  , "observe.js subscribed to builddown channel");

          mem.subscribe("executed", function(err){
            if(!err){
              log.info(ok
                      , "observe.js subscribed to executed channel");

              mem.subscribe("stop", function(err){
                if(!err){
                  log.info(ok
                          , "observe.js subscribed to stop channel");
                  if( _.isFunction(cb)){
                    cb(ok);
                  }
                }
              });
            }
          });
        }
      });
    }
  });
}
exports.ini = ini;

mem.on('message', function(ch, path){
  var strpath = path.join(" ")
    , mpid = path[0]
    , no   = path[1]

  log.info(ok
          , "observe.js received message on channel " + ch);

  if(ch == "executed" || ch == "stop"){

    log.info(ok
            , "receice " + ch +" event, try to set state ready");
    mem.get([mpid, no, "recipe"], function(err, recipe){
      if(!err){
        utils.cp([mpid, no, "state"], recipe , cstr.ready, function(){
          mem.publish("state", path, function(err){
            if(!err){
              log.info(ok
                      , "sync definition and state of container: "
                      + no + " next: check ctrl");
              mem.get([mpid, no, "ctrl"], function(err, cmdstr){
                if(!err &amp;&amp; cmdstr == "" || cmdstr == "stoping" ){
                  mem.set([mpid, no, "ctrl"], cstr.ready, function(err){
                    if(!err){
                      log.info(ok
                              , "set container to ready");
                    }else{
                      log.error({error:err}
                               , "on attempt to set container to ready");
                    }
                  }); // ctrl set
                } // cmd == ""
              }); // ctrl get
            }
          }); // publish state
        });
      }else{
        log.error({error:err}
                 , "error on try to get recipe");
      }
    });
  } // if executed

  if(ch == "builddown"){
    clearInterval(timerId[mpid]);
    timerId[mpid] = 0;
    log.info(ok
            , "clear interval on event builddown");
  } // if builddown

  if(ch == "buildup"){
    mem.get([mpid, "meta"], function(err, meta){
      var date   = new Date()
        , stime  = date.getTime()
        , path_e = [mpid, "exchange"]

      mem.set(path_e.concat(["start_time", "Value", "value"]), stime, function(err){
        mem.set(path_e.concat(["start_time", "Unit", "value"]), "ms", function(err){
          mem.set(path_e.concat(["run_time", "Unit", "value"]), "ms", function(err){

            log.info(ok
                    , "start observing " + mpid + " with " + sh + "ms");
            if(!timerId[mpid]){
              timerId[mpid] = setInterval(function(){
                                var rtime  = (new Date()).getTime() - stime
                                  , path_r = path_e.concat(["run_time"])
                                  , path_t =  path_r.concat(["Value", "value"]);
                                mem.set(path_t, rtime, function(err){
                                  mem.publish("timer", path, function(err){
                                    if(err){
                                      log.error({error:err}
                                               , " faild to publish timer event")
                                    }
                                  }); // timer

                                  for(var i = 0; i &lt; meta.container.N; i++){
                                    mem.get([mpid, i, "ctrl"], function(no){
                                                                 return function(err, cmdstr){
                                                                   if(_.isString(cmdstr)){
                                                                     var cmd    = _.first(utils.cmd_to_array(cmdstr))
                                                                       , nopath = [mpid, no]
                                                                       , spath  = [mpid, no, "state"];

                                                                     mem.get(spath, function(err, state_no){
                                                                       var flat_state = utils.as_arr(state_no)
                                                                         , all_exec   = utils.all_same(flat_state, cstr.exec);

                                                                       if( all_exec ){
                                                                         switch(cmd){
                                                                           case "monitoring":
                                                                           shout([mpid], cmdstr, no, cstr.mon, cstr.exec);
                                                                           break;
                                                                           case "":
                                                                           shout([mpid], cmdstr, no, cstr.ready, cstr.exec);
                                                                           break;
                                                                           default:
                                                                           shout([mpid], cmdstr, no, "", cstr.exec);
                                                                           break;
                                                                         }
                                                                       }else{
                                                                         switch(cmd){
                                                                           case cstr.stop:
                                                                           shout([mpid], cmdstr, no, "stoping", cstr.stop);
                                                                           break;

                                                                           case cstr.mon:
                                                                           shout([mpid], cmdstr, no, "monitoring", cstr.run);
                                                                           break;

                                                                           case cstr.load:
                                                                           shout([mpid], cmdstr, no, "loading", cstr.load);
                                                                           break;

                                                                           case cstr.run:
                                                                           shout([mpid], cmdstr, no, "running", cstr.run);
                                                                           break;
                                                                         } // swich
                                                                       }
                                                                     }); //nostate
                                                                   } // cmdstr is string
                                                                 }}(i)); // get ctrl
                                  } //for
                                }); // r time
                              }, sh); // intervall
            }else{ // timerId ae
              log.error({warn:"timer exists"}
                       , " observe timer for " + mpid + "already exists")
            }
          });
        });
      });
    }); // meta
  }// buildup
});

/**
 * Description
 * @method shout
 * @param {Array} path
 * @param {String} cmdstr
 * @param {Number} no
 * @param {String} cstr
 * @param {String} channel
 */
var shout = function(path, cmdstr, no, cstr, channel){
  var cmdarr = utils.cmd_to_array(cmdstr)
    , cmdH   = _.first(cmdarr)
    , cmdT   = _.rest(cmdarr)
    , nopath = path.concat([no])
    , cpath  = nopath.concat(["ctrl"])
    , spath  = nopath.concat(["state"])
    , ncmdstr;

  if(cstr){
    ncmdstr = [cstr].concat(cmdT).join(";")
  }else{
    ncmdstr = cmdT.join(";")
  }
  mem.set(cpath, ncmdstr, function(){
    mem.publish(channel, nopath, function(err){
      if(!err){
        log.info(ok
                , "published on channel: " + channel);
      }else{
        log.info({error:err}
                ,"error on publishing on channel: " + channel);
      }
    });
  }); // set ctrl loading
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#_">_</a></li><li><a href="global.html#all">all</a></li><li><a href="global.html#all_same">all_same</a></li><li><a href="global.html#as_arr">as_arr</a></li><li><a href="global.html#build_base">build_base</a></li><li><a href="global.html#build_container">build_container</a></li><li><a href="global.html#cb">cb</a></li><li><a href="global.html#checkDB">checkDB</a></li><li><a href="global.html#checkdb">checkdb</a></li><li><a href="global.html#checkRelay">checkRelay</a></li><li><a href="global.html#cmd_to_array">cmd_to_array</a></li><li><a href="global.html#container">container</a></li><li><a href="global.html#cp">cp</a></li><li><a href="global.html#ctrlContainer">ctrlContainer</a></li><li><a href="global.html#data_to_doc">data_to_doc</a></li><li><a href="global.html#distribute_def">distribute_def</a></li><li><a href="global.html#docinfo">docinfo</a></li><li><a href="global.html#eq">eq</a></li><li><a href="global.html#exec">exec</a></li><li><a href="global.html#expand_cust">expand_cust</a></li><li><a href="global.html#expand_task">expand_task</a></li><li><a href="global.html#exports">exports</a></li><li><a href="global.html#fetchtask">fetchtask</a></li><li><a href="global.html#getDate">getDate</a></li><li><a href="global.html#getList">getList</a></li><li><a href="global.html#getTime">getTime</a></li><li><a href="global.html#gt">gt</a></li><li><a href="global.html#ini">ini</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#lt">lt</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nodeRelay">nodeRelay</a></li><li><a href="global.html#pad0">pad0</a></li><li><a href="global.html#query_cd">query_cd</a></li><li><a href="global.html#rddoc">rddoc</a></li><li><a href="global.html#readExchange">readExchange</a></li><li><a href="global.html#relay">relay</a></li><li><a href="global.html#repl">repl</a></li><li><a href="global.html#replace_in_with">replace_in_with</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#shout">shout</a></li><li><a href="global.html#task">task</a></li><li><a href="global.html#task_exchange">task_exchange</a></li><li><a href="global.html#task_run_if">task_run_if</a></li><li><a href="global.html#task_stop_if">task_stop_if</a></li><li><a href="global.html#updateCd">updateCd</a></li><li><a href="global.html#vl_date">vl_date</a></li><li><a href="global.html#vl_time">vl_time</a></li><li><a href="global.html#wait">wait</a></li><li><a href="global.html#write_to_exchange">write_to_exchange</a></li><li><a href="global.html#writeExchange">writeExchange</a></li><li><a href="global.html#wrtdoc">wrtdoc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta1</a> on Mon Feb 16 2015 09:34:13 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
